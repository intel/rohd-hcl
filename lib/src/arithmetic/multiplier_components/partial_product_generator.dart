// Copyright (C) 2024-2025 Intel Corporation
// SPDX-License-Identifier: BSD-3-Clause
//
// partial_product_generator.dart
// Partial Product matrix generation from Booth recoded multiplicand
//
// 2024 May 15
// Author: Desmond Kirkpatrick <desmond.a.kirkpatrick@intel.com>

import 'dart:math';

import 'package:meta/meta.dart';
import 'package:rohd/rohd.dart';
import 'package:rohd_hcl/rohd_hcl.dart';

/// Store a Signbit as [Logic]
class SignBit extends Logic {
  /// This is an inverted sign bit
  bool inverted = false;

  /// Construct a sign bit to store
  SignBit(Logic inl, {this.inverted = false, String? name})
      : super(name: name ?? inl.name, naming: Naming.mergeable) {
    this <= inl;
  }
  @override
  SignBit clone({String? name}) =>
      SignBit(this, inverted: inverted, name: name);
}

/// A [PartialProductArray] is a class that holds a set of partial products
/// for manipulation by [PartialProductGeneratorBase] and column compressor.
abstract class PartialProductArray {
  /// Name used for [PartialProductArray] instances.
  final String name;

  /// Construct a basic [List<List<Logic>>] to hold an array of partial products
  /// as well as a rowShift array to hold the row shifts.
  PartialProductArray({this.name = 'ppa'});

  /// The actual shift in each row. This value will be modified by the
  /// sign extension routine used when folding in a sign bit from another
  /// row.
  final rowShift = <int>[];

  /// Partial Products output. Generated by selector and extended by sign
  /// extension routines.
  late final List<List<Logic>> partialProducts;

  /// Number of rows of partial products.
  int get rows => partialProducts.length;

  /// Return the actual largest width of all rows
  int maxWidth() {
    var maxW = 0;
    for (var row = 0; row < rows; row++) {
      final entry = partialProducts[row];
      if (entry.length + rowShift[row] > maxW) {
        maxW = entry.length + rowShift[row];
      }
    }
    return maxW;
  }

  /// Return the [Logic] at the absolute position ([row], [col]).
  Logic getAbsolute(int row, int col) {
    final product = partialProducts[row];
    while (product.length <= col) {
      product.add(Const(0));
    }
    return partialProducts[row][col - rowShift[row]];
  }

  /// Return the [List<Logic>] at the absolute position ([row], [List<int>]
  /// [columns].
  List<Logic> getAbsoluteAll(int row, List<int> columns) {
    final product = partialProducts[row];
    final relMax = columns.reduce(max);
    final absMax = relMax - rowShift[row];
    while (product.length <= absMax) {
      product.add(Const(0));
    }
    return [for (final c in columns) partialProducts[row][c - rowShift[row]]];
  }

  /// Set the [Logic] at absolute position ([row], [col]) to [val].
  void setAbsolute(int row, int col, Logic val) {
    final product = partialProducts[row];
    final i = col - rowShift[row];
    if (product.length > i) {
      product[i] = val;
    } else {
      while (product.length < i) {
        product.add(Const(0));
      }
      partialProducts[row].add(val);
    }
  }

  /// Mux the [Logic] at absolute position ([row], [col]) conditionally by
  /// [condition] to [val].
  void muxAbsolute(int row, int col, Logic condition, Logic val) {
    final product = partialProducts[row];
    final i = col - rowShift[row];
    if (product.length > i) {
      if (val is SignBit || product[i] is SignBit) {
        var inv = false;
        if (val is SignBit) {
          inv = val.inverted;
        }
        if (product[i] is SignBit) {
          inv = (product[i] as SignBit).inverted;
        }
        product[i] = SignBit(mux(condition, val, product[i]), inverted: inv);
      } else {
        product[i] = mux(condition, val, product[i]);
      }
    } else {
      while (product.length < i) {
        product.add(Const(0));
      }
      partialProducts[row].add(val);
    }
  }

  /// Set the range at absolute position ([row], [col]) to [list].
  void setAbsoluteAll(int row, int col, List<Logic> list) {
    var i = col - rowShift[row];
    final product = partialProducts[row];
    for (final val in list) {
      if (product.length > i) {
        product[i++] = val;
      } else {
        while (product.length < i) {
          product.add(Const(0));
        }
        product.add(val);
        i++;
      }
    }
  }

  /// Mux the range of values into the row starting at absolute position
  ///  ([row], [col]) using [condition] to select the new value.
  void muxAbsoluteAll(int row, int col, Logic condition, List<Logic> list) {
    var i = col - rowShift[row];
    final product = partialProducts[row];
    for (final val in list) {
      if (product.length > i) {
        if (val is SignBit || product[i] is SignBit) {
          var inv = false;
          if (val is SignBit) {
            inv = val.inverted;
          }
          if (product[i] is SignBit) {
            inv = (product[i] as SignBit).inverted;
          }
          product[i] = SignBit(mux(condition, val, product[i]), inverted: inv);
        } else {
          product[i] = mux(condition, val, product[i]);
        }
        i++;
      } else {
        while (product.length < i) {
          product.add(Const(0));
        }
        if (val is SignBit) {
          product.add(
              SignBit(mux(condition, val, Const(0)), inverted: val.inverted));
        } else {
          product.add(mux(condition, val, Const(0)));
        }
        i++;
      }
    }
  }

  /// Set a [Logic] [val] at the absolute position ([row], [col]).
  void insertAbsolute(int row, int col, Logic val) =>
      partialProducts[row].insert(col - rowShift[row], val);

  /// Set the values of the row, starting at absolute position ([row], [col])
  /// to the [list] of values
  void insertAbsoluteAll(int row, int col, List<Logic> list) =>
      partialProducts[row].insertAll(col - rowShift[row], list);
}

/// A [PartialProductGeneratorBase] class that generates a set of partial
///  products. Essentially a set of shifted rows of [Logic] addends generated by
///  Booth recoding and manipulated by sign extension, before being compressed.
abstract class PartialProductGeneratorBase extends PartialProductArray {
  /// Get the shift increment between neighboring product rows.
  int get shift => selector.shift;

  /// The multiplicand term.
  Logic get multiplicand => selector.multiplicand;

  /// The multiplier term.
  Logic get multiplier => encoder.multiplier;

  /// Encoder for the full multiply operand.
  late final MultiplierEncoder encoder;

  /// Selector for the multiplicand which uses the encoder to index into
  /// multiples of the multiplicand and generate partial products.
  late final MultiplicandSelector selector;

  /// [multiplicand] operand is always signed.
  final bool signedMultiplicand;

  /// [multiplier] operand is always signed.
  final bool signedMultiplier;

  /// Used to avoid sign extending more than once.
  bool isSignExtended = false;

  /// If not null, use this signal to select between signed and unsigned
  /// [multiplicand].
  final Logic? selectSignedMultiplicand;

  /// If not null, use this signal to select between signed and unsigned
  /// [multiplier].
  final Logic? selectSignedMultiplier;

  /// Construct a [PartialProductGeneratorBase] -- the partial product matrix.
  ///
  /// [signedMultiplicand] generates a fixed signed encoder versus using
  /// [selectSignedMultiplicand] which is a runtime sign selection [Logic]
  /// in which case [signedMultiplicand] must be `false`.
  ///
  /// [signedMultiplier] generates a fixed signed encoder versus using
  /// [selectSignedMultiplier] which is a runtime sign selection [Logic]
  /// in which case [signedMultiplier] must be `false`.
  PartialProductGeneratorBase(
      Logic multiplicand, Logic multiplier, RadixEncoder radixEncoder,
      {this.signedMultiplicand = false,
      this.signedMultiplier = false,
      this.selectSignedMultiplicand,
      this.selectSignedMultiplier,
      super.name = 'ppg'}) {
    if (signedMultiplicand && (selectSignedMultiplicand != null)) {
      throw RohdHclException('multiplicand sign reconfiguration requires '
          'signedMultiplicand=false');
    }
    if (signedMultiplier && (selectSignedMultiplier != null)) {
      throw RohdHclException('sign reconfiguration requires signed=false');
    }
    selector = MultiplicandSelector(radixEncoder.radix, multiplicand,
        signedMultiplicand: signedMultiplicand,
        selectSignedMultiplicand: selectSignedMultiplicand);
    encoder = MultiplierEncoder(multiplier, radixEncoder,
        signedMultiplier: signedMultiplier,
        selectSignedMultiplier: selectSignedMultiplier);

    if (multiplicand.width < selector.shift) {
      throw RohdHclException('multiplicand width must be greater than '
          'or equal to ${selector.shift}');
    }
    if (multiplier.width < (selector.shift + (signedMultiplier ? 1 : 0))) {
      throw RohdHclException('multiplier width must be greater than '
          'or equal to ${selector.shift + (signedMultiplier ? 1 : 0)}');
    }
    _build();
  }

  /// Perform sign extension (defined in child classes).
  @Deprecated('Replace this call with a construction of a '
      '[PartialProductSignExtension] class')
  @protected
  void signExtend();

  /// Setup the partial products array ([partialProducts] and [rowShift]).
  void _build() {
    partialProducts = <List<Logic>>[];
    for (var row = 0; row < encoder.rows; row++) {
      partialProducts.add(List.generate(
          selector.width,
          (i) => selector
              .select(i, encoder.fetchEncoding(row))
              .named('pp_r${row}_c$i', naming: Naming.mergeable)));
    }
    for (var row = 0; row < rows; row++) {
      rowShift.add(row * shift);
    }
  }
}

/// An module API that represents a set of partial products rows including
/// their shifts. This is a base class for the [PartialProduct] module.
abstract class PartialProductMatrix extends Module {
  /// Give access for things like [ColumnCompressor].
  /// This is an output, but not yet generated?
  List<Logic> get rows {
    if (!_outputsGenerated) {
      throw RohdHclException('generate outputs before accessing rows');
    }
    return [for (var row = 0; row < _array.rows; row++) output('row_$row')];
  }

  /// Give access to the _array for [PartialProductSignExtension] to operate.
  PartialProductGeneratorBase get array => _array;

  /// Give access to the _array for [PartialProductSignExtension] to operate.
  List<int> get rowShift => _array.rowShift;

  bool _outputsGenerated = false;

  /// Store the [PartialProductGeneratorBase]
  late final PartialProductGeneratorBase _array;

  /// Base constructor for the matrix
  PartialProductMatrix(
      {super.name = 'partial_product_matrix',
      super.reserveName,
      super.reserveDefinitionName,
      String? definitionName})
      : super(definitionName: definitionName ?? 'PartialProductMatrix');

  /// Generate the output vectors from the array
  void generateOutputs() {
    for (var row = 0; row < _array.rows; row++) {
      addOutput('row_$row', width: _array.partialProducts[row].length) <=
          _array.partialProducts[row].rswizzle();
    }
    _outputsGenerated = true;
  }
}

/// A [PartialProduct] module wrapping partial product array manipulation
/// and generation of outputs in an actual module as opposed to an inline
/// generator class.
class PartialProduct extends PartialProductMatrix {
  /// Create a [PartialProduct] [Module] which manages a
  /// [PartialProductArray].
  PartialProduct(
      Logic multiplicand, Logic multiplier, RadixEncoder radixEncoder,
      {bool signedMultiplicand = false,
      bool signedMultiplier = false,
      Logic? selectSignedMultiplicand,
      Logic? selectSignedMultiplier,
      PartialProductGeneratorBase Function(
              Logic multiplicand, Logic multiplier, RadixEncoder radixEncoder,
              {bool signedMultiplicand,
              bool signedMultiplier,
              Logic? selectSignedMultiplicand,
              Logic? selectSignedMultiplier})
          genPPG = PartialProductGenerator.new,
      super.name = 'partial_product',
      super.reserveName,
      super.reserveDefinitionName,
      String? definitionName})
      : super(
            definitionName: definitionName ??
                'PartialProduct_W${multiplicand.width}x${multiplier.width}'
                    '_${Multiplier.signedMD(signedMultiplicand)}_'
                    '${Multiplier.signedML(signedMultiplier)}') {
    final selectSignedMultiplicandInternal = selectSignedMultiplicand != null
        ? addInput(selectSignedMultiplicand.name, selectSignedMultiplicand)
        : null;
    final selectSignedMultiplierInternal = selectSignedMultiplier != null
        ? addInput(selectSignedMultiplier.name, selectSignedMultiplier)
        : null;

    final localMultiplicand =
        addInput('multiplicand', multiplicand, width: multiplicand.width);
    final localMultiplier =
        addInput('multiplier', multiplier, width: multiplier.width);
    _array = genPPG(localMultiplicand, localMultiplier, radixEncoder,
        signedMultiplicand: signedMultiplicand,
        signedMultiplier: signedMultiplier,
        selectSignedMultiplicand: selectSignedMultiplicandInternal,
        selectSignedMultiplier: selectSignedMultiplierInternal);
  }
}
