// Copyright (C) 2024-2025 Intel Corporation
// SPDX-License-Identifier: BSD-3-Clause
//
// partial_product_test_sign_extend.dart
// Partial Product Genereator sign extension methods.
//
// 2024 May 15
// Author: Desmond Kirkpatrick <desmond.a.kirkpatrick@intel.com>

import 'dart:math';

import 'package:rohd/rohd.dart';
import 'package:rohd_hcl/rohd_hcl.dart';

/// Methods for sign extending the [PartialProductGeneratorBase]
enum SignExtension {
  /// No sign extension
  none,

  /// Brute force sign extend each row to the full width of the product
  brute,

  /// Extend using stop bits in each row (and an extra row for final sign)
  stopBits,

  /// Fold in last row sign bit (Mohanty, B.K., Choubey, A.)
  compact,

  /// Sign folding that works for rectangular partial products
  compactRect
}

/// Used to test different sign extension methods
typedef PPGFunction = PartialProductGeneratorBase Function(
    Logic a, Logic b, RadixEncoder radixEncoder,
    {bool signedMultiplicand,
    Logic? selectSignedMultiplicand,
    bool signedMultiplier,
    Logic? selectSignedMultiplier});

/// API for sign extension classes
abstract class PartialProductSignExtension {
  /// name used for PartialProductSignExtension
  final String name;

  /// The partial product generator we are sign extending.
  final PartialProductGeneratorBase ppg;

  /// multiplicand operand is always signed.
  bool get signedMultiplicand => ppg.signedMultiplicand;

  /// multiplier operand is always signed.
  bool get signedMultiplier => ppg.signedMultiplier;

  /// If not null, use this signal to select between signed and unsigned
  /// multiplicand.
  Logic? get selectSignedMultiplicand => ppg.selectSignedMultiplicand;

  /// If not null, use this signal to select between signed and unsigned
  /// multiplier.
  Logic? get selectSignedMultiplier => ppg.selectSignedMultiplier;

  /// Number of rows of partial products.
  int get rows => ppg.rows;

  /// The actual shift in each row. This value will be modified by the
  /// sign extension routine used when folding in a sign bit from another
  /// row.
  List<int> get rowShift => ppg.rowShift;

  /// Partial Products output. Generated by selector and extended by sign
  /// extension routines.
  List<List<Logic>> get partialProducts => ppg.partialProducts;

  /// Used to avoid sign extending more than once.
  bool get isSignExtended => ppg.isSignExtended;
  set isSignExtended(bool set) {
    ppg.isSignExtended = set;
  }

  /// Get the shift increment between neighboring product rows.
  int get shift => ppg.shift;

  /// Encoder for the full multiply operand. Used here just to get signs[].
  MultiplierEncoder get encoder => ppg.encoder; // signs getter

  // is multiplicand.width == entry.length?
  // width=> multiplicand.width + shift - 1;
  /// Only used to get width as above
  MultiplicandSelector get selector => ppg.selector; // selector.width accessed

  /// Sign Extension class that operates on a [PartialProductGeneratorBase]
  /// and sign-extends the entries.
  PartialProductSignExtension(this.ppg, {this.name = 'no_sign_extension'}) {
    if (signedMultiplier && (selectSignedMultiplier != null)) {
      throw RohdHclException('sign reconfiguration requires signed=false');
    }
    if (signedMultiplicand && (selectSignedMultiplicand != null)) {
      throw RohdHclException('multiplicand sign reconfiguration requires '
          'signedMultiplicand=false');
    }
  }

  /// Execute the sign extension, overridden to specialize.
  void signExtend();

  /// Helper function for sign extension routines:
  /// For signed operands, set the MSB to [sign], otherwise add this [sign] bit.
  void addStopSign(List<Logic> addend, SignBit sign) {
    if (!signedMultiplicand) {
      addend.add(sign);
    } else {
      addend.last = sign;
    }
  }

  /// Helper function for sign extension routines:
  /// For signed operands, flip the MSB, otherwise add this [sign] bit.
  void addStopSignFlip(List<Logic> addend, SignBit sign) {
    if (!signedMultiplicand) {
      if (selectSignedMultiplicand == null) {
        addend.add(sign);
      } else {
        addend.add(SignBit(mux(selectSignedMultiplicand!, ~addend.last, sign),
            inverted: selectSignedMultiplicand != null));
      }
    } else {
      addend.last = SignBit(~addend.last, inverted: true);
    }
  }
}

/// Used to test different sign extension methods
typedef SignExtensionFunction = PartialProductSignExtension
    Function(PartialProductGeneratorBase ppg, {String name});

/// Used to test different sign extension methods
SignExtensionFunction currySignExtensionFunction(SignExtension signExtension) =>
    switch (signExtension) {
      SignExtension.none => NoneSignExtension.new,
      SignExtension.brute => BruteSignExtension.new,
      SignExtension.stopBits => StopBitsSignExtension.new,
      SignExtension.compact => CompactSignExtension.new,
      SignExtension.compactRect => CompactRectSignExtension.new,
    };

/// A range of SignExtension classes to be used in building new arithmetic
/// building blocks.  Start with [BruteSignExtension] when composing new
/// partial product array shapes as it should work in all situations.

/// A Partial Product Generator using None Sign Extension
class NoneSignExtension extends PartialProductSignExtension {
  /// Construct a no sign-extension class.
  NoneSignExtension(super.ppg, {super.name = 'none_sign_extension'});

  /// Fully sign extend the PP array: useful for reference only
  @override
  void signExtend() {}
}

/// A concrete base class for partial product generation
class PartialProductGeneratorBasic extends PartialProductGeneratorBase {
  /// The extension routine we will be using.
  late final PartialProductSignExtension extender;

  /// Construct a none sign extending Partial Product Generator
  PartialProductGeneratorBasic(
      super.multiplicand, super.multiplier, super.radixEncoder,
      {super.signedMultiplicand,
      super.signedMultiplier,
      super.selectSignedMultiplicand,
      super.selectSignedMultiplier,
      super.name = 'none'}) {
    extender = NoneSignExtension(this);
    signExtend();
  }

  @override
  void signExtend() {
    extender.signExtend();
  }
}

/// A Brute Sign Extension class.
class BruteSignExtension extends PartialProductSignExtension {
  /// Construct a brute-force sign extending Partial Product Generator
  BruteSignExtension(super.ppg, {super.name = 'brute_sign_extension'});

  /// Fully sign extend the PP array: useful for reference only
  @override
  void signExtend() {
    if (signedMultiplicand && (selectSignedMultiplicand != null)) {
      throw RohdHclException('multiplicand sign reconfiguration requires '
          'signedMultiplicand=false');
    }
    if (isSignExtended) {
      throw RohdHclException('Partial Product array already sign-extended');
    }
    isSignExtended = true;
    final signs = [
      for (var r = 0; r < rows; r++)
        nameLogic(
            'sign_r$r', naming: Naming.mergeable, encoder.fetchEncoding(r).sign)
    ];
    for (var row = 0; row < rows; row++) {
      final addend = partialProducts[row];
      final Logic sign;
      if (selectSignedMultiplicand != null) {
        sign = mux(selectSignedMultiplicand!, addend.last, signs[row]);
      } else {
        sign = signedMultiplicand ? addend.last : signs[row];
      }
      addend.addAll(List.filled((rows - row) * shift, SignBit(sign)));
      if (row > 0) {
        addend
          ..insertAll(0, List.filled(shift - 1, Const(0)))
          ..insert(0, SignBit(signs[row - 1]));
        rowShift[row] -= shift;
      }
    }
    // Insert carry bit in extra row
    partialProducts.add(List.generate(selector.width, (i) => Const(0)));
    partialProducts.last.insert(0, SignBit(signs[rows - 2]));
    rowShift.add((rows - 2) * shift);
  }
}

/// A wrapper class for [BruteSignExtension] we used
/// during refactoring to be compatible with old calls.
@Deprecated('Use BruteSignExtension class after PartialProductGeneratorBasic')
class PartialProductGeneratorBruteSignExtension
    extends PartialProductGeneratorBase {
  /// The extension routine we will be using.
  late final PartialProductSignExtension extender;

  /// Construct a compact rect sign extending Partial Product Generator
  @Deprecated('Use BruteSignExtension class after PartialProductGeneratorBasic')
  PartialProductGeneratorBruteSignExtension(
      super.multiplicand, super.multiplier, super.radixEncoder,
      {super.signedMultiplicand,
      super.signedMultiplier,
      super.selectSignedMultiplicand,
      super.selectSignedMultiplier,
      super.name = 'brute'}) {
    extender = BruteSignExtension(this);
    signExtend();
  }

  @override
  void signExtend() {
    extender.signExtend();
  }
}

/// A Compact Sign Extension class.
class CompactSignExtension extends PartialProductSignExtension {
  /// Construct a compact sign extendsion class.
  CompactSignExtension(super.ppg, {super.name = 'compact_sign_extension'});

  @override
  void signExtend() {
    // An implementation of
    // Mohanty, B.K., Choubey, A. Efficient Design for Radix-8 Booth Multiplier
    // and Its Application in Lifting 2-D DWT. Circuits Syst Signal Process 36,
    // 1129â€“1149 (2017). https://doi.org/10.1007/s00034-016-0349-9
    if (signedMultiplicand && (selectSignedMultiplicand != null)) {
      throw RohdHclException('multiplicand sign reconfiguration requires '
          'signedMultiplicand=false');
    }
    if (isSignExtended) {
      throw RohdHclException('Partial Product array already sign-extended');
    }
    isSignExtended = true;

    final lastRow = rows - 1;
    final firstAddend = partialProducts[0];
    final lastAddend = partialProducts[lastRow];

    final firstRowQStart = selector.width - (signedMultiplicand ? 1 : 0);
    final lastRowSignPos = shift * lastRow;
    final alignRow0Sign = firstRowQStart - lastRowSignPos;

    final signs = [
      for (var r = 0; r < rows; r++)
        nameLogic(
            'sign_r$r', naming: Naming.mergeable, encoder.fetchEncoding(r).sign)
    ];

    final propagate =
        List.generate(rows, (i) => List.filled(0, Logic(), growable: true));

    for (var row = 0; row < rows; row++) {
      propagate[row].add(signs[row]);
      for (var col = 0; col < 2 * (shift - 1); col++) {
        propagate[row].add(nameLogic(
            'propagate_r${row}_c$col',
            naming: Naming.mergeable,
            partialProducts[row][col]));
      }
      // Last row has extend sign propagation to Q start
      if (row == lastRow) {
        var col = 2 * (shift - 1);
        while (propagate[lastRow].length <= alignRow0Sign) {
          propagate[lastRow].add(SignBit(partialProducts[row][col++]));
        }
      }
      for (var col = 1; col < propagate[row].length; col++) {
        propagate[row][col] = nameLogic(
            'propagate_r${row}_c$col',
            naming: Naming.mergeable,
            propagate[row][col] & propagate[row][col - 1]);
      }
    }
    final m =
        List.generate(rows, (i) => List.filled(0, Logic(), growable: true));
    for (var row = 0; row < rows; row++) {
      for (var c = 0; c < shift - 1; c++) {
        m[row].add(nameLogic(
            'm_r${row}_c$c',
            naming: Naming.mergeable,
            partialProducts[row][c] ^ propagate[row][c]));
      }
      m[row].addAll(List.filled(shift - 1, Logic()));
    }
    while (m[lastRow].length < alignRow0Sign) {
      m[lastRow].add(Logic());
    }
    // TODO(desmonddak): this seems unused when looking at Verilog output
    for (var i = shift - 1; i < m[lastRow].length; i++) {
      m[lastRow][i] = nameLogic(
          'm_lastr_c$i',
          naming: Naming.mergeable,
          lastAddend[i] ^
              (i < alignRow0Sign ? propagate[lastRow][i] : Const(0)));
    }

    final remainders = List.filled(rows, Logic());
    for (var row = 0; row < lastRow; row++) {
      remainders[row] = nameLogic(
          'remainders_r$row',
          naming: Naming.mergeable,
          propagate[row][shift - 1]);
    }
    remainders[lastRow] <=
        nameLogic(
            'remainders_lastrow',
            naming: Naming.mergeable,
            propagate[lastRow][max(alignRow0Sign, 0)]);

    // Compute Sign extension for row==0
    final firstSign = Logic(name: 'firstsign', naming: Naming.mergeable);
    if (selectSignedMultiplicand == null) {
      firstSign <=
          (signedMultiplicand ? SignBit(firstAddend.last) : SignBit(signs[0]));
    } else {
      firstSign <=
          SignBit(mux(selectSignedMultiplicand!, firstAddend.last, signs[0]));
    }
    final q = [
      nameLogic('q0', firstSign ^ remainders[lastRow]),
      nameLogic('q1', ~(firstSign & ~remainders[lastRow])),
    ];
    q.insertAll(1, List.filled(shift - 1, ~q[1]));

    for (var row = 0; row < rows; row++) {
      final addend = partialProducts[row];
      if (row > 0) {
        final mLimit = (row == lastRow) ? alignRow0Sign : shift - 1;
        for (var i = 0; i < mLimit; i++) {
          addend[i] = m[row][i];
        }
        addStopSignFlip(addend, SignBit(~signs[row], inverted: true));
        addend
          ..insert(0, remainders[row - 1])
          ..addAll(List.filled(shift - 1, Const(1)));
        rowShift[row] -= 1;
      } else {
        for (var i = 0; i < shift - 1; i++) {
          firstAddend[i] = m[0][i];
        }
        if (!signedMultiplicand) {
          firstAddend.add(q[0]);
        } else {
          firstAddend.last = q[0];
        }
        firstAddend.addAll(q.getRange(1, q.length));
      }
    }
    if (shift == 1) {
      lastAddend.add(Const(1));
    }
  }
}

/// A wrapper class for [CompactSignExtension] we used
/// during refactoring to be compatible with old calls.
@Deprecated('Use CompactSignExtension class after PartialProductGeneratorBasic')
class PartialProductGeneratorCompactSignExtension
    extends PartialProductGeneratorBase {
  /// The extension routine we will be using.
  late final PartialProductSignExtension extender;

  /// Construct a compact sign extending Partial Product Generator
  @Deprecated(
      'Use CompactSignExtension class after PartialProductGeneratorBasic')
  PartialProductGeneratorCompactSignExtension(
      super.multiplicand, super.multiplier, super.radixEncoder,
      {super.signedMultiplicand,
      super.signedMultiplier,
      super.selectSignedMultiplicand,
      super.selectSignedMultiplier,
      super.name = 'compact'}) {
    extender = CompactSignExtension(this);
    signExtend();
  }

  @override
  void signExtend() {
    extender.signExtend();
  }
}

/// A StopBits Sign Extension.
class StopBitsSignExtension extends PartialProductSignExtension {
  /// Construct a stop bits sign extendsion class.
  StopBitsSignExtension(super.ppg, {super.name = 'stopbits_sign_extension'});

  /// Sign extend the PP array using stop bits.
  /// If possible, fold the final carry into another row (only when rectangular
  /// enough that carry bit lands outside another row).
  /// This technique can then be combined with a first-row extension technique
  /// for folding in the final carry.
  ///
  @override
  void signExtend() {
    if (signedMultiplicand && (selectSignedMultiplicand != null)) {
      throw RohdHclException('multiplicand sign reconfiguration requires '
          'signedMultiplicand=false');
    }
    if (isSignExtended) {
      throw RohdHclException('Partial Product array already sign-extended');
    }
    isSignExtended = true;

    final finalCarryPos = shift * (rows - 1);
    final finalCarryRelPos = finalCarryPos - selector.width - shift;
    final finalCarryRow =
        ((encoder.multiplier.width > selector.multiplicand.width) &&
                (finalCarryRelPos > 0))
            ? (finalCarryRelPos / shift).floor()
            : 0;

    final signs = [
      for (var r = 0; r < rows; r++)
        nameLogic(
          'sign_r$r',
          naming: Naming.mergeable,
          encoder.fetchEncoding(r).sign,
        )
    ];

    for (var row = 0; row < rows; row++) {
      final addend = partialProducts[row];
      final Logic sign;
      if (selectSignedMultiplicand != null) {
        sign = mux(selectSignedMultiplicand!, addend.last, signs[row]);
      } else {
        sign = signedMultiplicand ? addend.last : signs[row];
      }
      if (row == 0) {
        if (!signedMultiplicand) {
          addend.addAll(List.filled(shift, SignBit(sign)));
        } else {
          // either is signed?
          addend.addAll(List.filled(shift - 1, SignBit(sign))); // signed only?
        }
        addend.add(SignBit(~sign, inverted: true));
      } else {
        addStopSign(addend, SignBit(~sign, inverted: true));
        addend
          ..addAll(List.filled(shift - 1, Const(1)))
          ..insertAll(0, List.filled(shift - 1, Const(0)))
          ..insert(0, SignBit(signs[row - 1]));
        rowShift[row] -= shift;
      }
    }

    if (finalCarryRow > 0) {
      final extensionRow = partialProducts[finalCarryRow];
      extensionRow
        ..addAll(List.filled(
            finalCarryPos - (extensionRow.length + rowShift[finalCarryRow]),
            Const(0)))
        ..add(SignBit(signs[rows - 1]));
    } else if (signedMultiplier | (selectSignedMultiplier != null)) {
      // Create an extra row to hold the final carry bit
      partialProducts
          .add(List.filled(selector.width, Const(0), growable: true));
      partialProducts.last.insert(0, SignBit(signs[rows - 2]));
      rowShift.add((rows - 2) * shift);

      // Hack for radix-2
      if (shift == 1) {
        addStopSignFlip(
            partialProducts.last, SignBit(Const(1), inverted: true));
      }
    }
  }
}

/// Stop-bits based sign extension
@Deprecated(
    'Use StopBitsSignExtension class after PartialProductGeneratorBasic')
class PartialProductGeneratorStopBitsSignExtension
    extends PartialProductGeneratorBase {
  /// The extension routine we will be using.
  late final PartialProductSignExtension extender;

  /// Construct a stop bits sign extending Partial Product Generator
  @Deprecated(
      'Use StopBitsSignExtension class after PartialProductGeneratorBasic')
  PartialProductGeneratorStopBitsSignExtension(
      super.multiplicand, super.multiplier, super.radixEncoder,
      {super.signedMultiplicand,
      super.signedMultiplier,
      super.selectSignedMultiplicand,
      super.selectSignedMultiplier,
      super.name = 'stop_bits'}) {
    extender = StopBitsSignExtension(this);
    signExtend();
  }

  @override
  void signExtend() {
    extender.signExtend();
  }
}

/// A wrapper class for [CompactRectSignExtension] we used
/// during refactoring to be compatible with old calls.
@Deprecated(
    'Use CompactRectSignExtension class after PartialProductGeneratorBasic')
class PartialProductGeneratorCompactRectSignExtension
    extends PartialProductGeneratorBase {
  /// The extension routine we will be using.
  late final PartialProductSignExtension extender;

  /// Construct a compact rect sign extending Partial Product Generator
  @Deprecated(
      'Use CompactRectSignExtension class after PartialProductGeneratorBasic')
  PartialProductGeneratorCompactRectSignExtension(
      super.multiplicand, super.multiplier, super.radixEncoder,
      {super.signedMultiplicand,
      super.signedMultiplier,
      super.selectSignedMultiplicand,
      super.selectSignedMultiplier,
      super.name = 'compact_rect'}) {
    extender = CompactRectSignExtension(this);
    signExtend();
  }

  @override
  void signExtend() {
    extender.signExtend();
  }
}

/// A Partial Product Generator using Compact Rectangular Extension
class CompactRectSignExtension extends PartialProductSignExtension {
  /// Sign extend the PP array using stop bits without adding a row
  /// This routine works with different widths of multiplicand/multiplier,
  /// an extension of Mohanty, B.K., Choubey designed by
  /// Desmond A. Kirkpatrick.
  CompactRectSignExtension(super.ppg,
      {super.name = 'compactrect_sign_extension'});

  @override
  void signExtend() {
    if (isSignExtended) {
      throw RohdHclException('Partial Product array already sign-extended');
    }
    isSignExtended = true;

    final lastRow = rows - 1;
    final firstAddend = partialProducts[0];
    final lastAddend = partialProducts[lastRow];

    final firstRowQStart = selector.width - (signedMultiplicand ? 1 : 0);
    final lastRowSignPos = shift * lastRow;

    final align = firstRowQStart - lastRowSignPos;

    final signs = [
      for (var r = 0; r < rows; r++)
        nameLogic(
          'sign_r$r',
          naming: Naming.mergeable,
          encoder.fetchEncoding(r).sign,
        )
    ];

    // Compute propgation info for folding sign bits into main rows
    final propagate =
        List.generate(rows, (i) => List.filled(0, Logic(), growable: true));

    for (var row = 0; row < rows; row++) {
      propagate[row].add(SignBit(signs[row]));
      for (var col = 0; col < 2 * (shift - 1); col++) {
        propagate[row].add(nameLogic(
            'propagate_r${row}_c$col',
            naming: Naming.mergeable,
            partialProducts[row][col]));
      }
      // Last row has extend sign propagation to Q start
      if (row == lastRow) {
        var col = 2 * (shift - 1);
        while (propagate[lastRow].length <= align) {
          propagate[lastRow].add(SignBit(partialProducts[row][col++]));
        }
      }
      // Now compute the propagation logic
      for (var col = 1; col < propagate[row].length; col++) {
        propagate[row][col] = nameLogic(
            'propagate_r${row}_c$col',
            naming: Naming.mergeable,
            propagate[row][col] & propagate[row][col - 1]);
      }
    }

    // Compute 'm', the prefix of each row to carry the sign of the next row
    final m =
        List.generate(rows, (i) => List.filled(0, Logic(), growable: true));
    for (var row = 0; row < rows; row++) {
      for (var c = 0; c < shift - 1; c++) {
        m[row].add(nameLogic(
            'm_r${row}_c$c', partialProducts[row][c] ^ propagate[row][c]));
      }
      m[row].addAll(List.filled(shift - 1, Logic()));
    }

    while (m[lastRow].length < align) {
      m[lastRow].add(Logic());
    }
    for (var i = shift - 1; i < m[lastRow].length; i++) {
      m[lastRow][i] = nameLogic(
          'm_lastrow_$i',
          naming: Naming.mergeable,
          lastAddend[i] ^ (i < align ? propagate[lastRow][i] : Const(0)));
    }

    final remainders = List.filled(rows, Logic());
    for (var row = 0; row < lastRow; row++) {
      remainders[row] = nameLogic(
          'remainder_r$row',
          naming: Naming.mergeable,
          propagate[row][shift - 1]);
    }
    remainders[lastRow] = nameLogic(
        'remainder_lastrow',
        naming: Naming.mergeable,
        propagate[lastRow][align > 0 ? align : 0]);

    // Merge 'm' into the LSBs of each addend
    for (var row = 0; row < rows; row++) {
      final addend = partialProducts[row];
      if (row > 0) {
        final mLimit = (row == lastRow) ? align : shift - 1;
        for (var i = 0; i < mLimit; i++) {
          addend[i] = m[row][i];
        }
        // Stop bits
        addStopSignFlip(addend, SignBit(~signs[row], inverted: true));
        addend
          ..insert(0, remainders[row - 1])
          ..addAll(List.filled(shift - 1, Const(1)));
        rowShift[row] -= 1;
      } else {
        // First row
        for (var i = 0; i < shift - 1; i++) {
          firstAddend[i] = m[0][i];
        }
      }
    }

    // Insert the lastRow sign:  Either in firstRow's Q if there is a
    // collision or in another row if it lands beyond the Q sign extension
    final firstSign = Logic(name: 'firstsign', naming: Naming.mergeable);
    if (selectSignedMultiplicand == null) {
      firstSign <=
          (signedMultiplicand ? SignBit(firstAddend.last) : SignBit(signs[0]));
    } else {
      firstSign <=
          (SignBit(mux(selectSignedMultiplicand!, firstAddend.last, signs[0])));
    }
    final lastSign = SignBit(remainders[lastRow]);
    // Compute Sign extension MSBs for firstRow
    final qLen = shift + 1;
    final insertSignPos = (align > 0) ? 0 : -align;
    final q = List.filled(min(qLen, insertSignPos), firstSign, growable: true);
    if (insertSignPos < qLen) {
      // At sign insertion position
      q.add(SignBit(firstSign ^ lastSign));
      if (insertSignPos == qLen - 1) {
        q[insertSignPos] = SignBit(~q[insertSignPos], inverted: true);
        q.add(SignBit(~(firstSign | q[insertSignPos]), inverted: true));
      } else {
        q
          ..addAll(List.filled(
              qLen - insertSignPos - 2, SignBit(firstSign & ~lastSign)))
          ..add(SignBit(~(firstSign & ~lastSign), inverted: true));
      }
    }

    if (-align >= q.length) {
      q.last = SignBit(~firstSign, inverted: true);
    }
    addStopSign(firstAddend, SignBit(q[0]));
    firstAddend.addAll(q.getRange(1, q.length));

    if (-align >= q.length) {
      final finalCarryRelPos = lastRowSignPos -
          selector.width -
          shift +
          (signedMultiplicand ? 1 : 0);
      final finalCarryRow = (finalCarryRelPos / shift).floor();
      final curRowLength =
          partialProducts[finalCarryRow].length + rowShift[finalCarryRow];

      partialProducts[finalCarryRow]
        ..addAll(List.filled(lastRowSignPos - curRowLength, Const(0)))
        ..add(remainders[lastRow]);
    }
    if (shift == 1) {
      lastAddend.add(Const(1));
    }
  }
}
